package jboost.atree;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;

import jboost.ComplexLearner;
import jboost.WritablePredictor;
import jboost.booster.Booster;
import jboost.booster.Prediction;
import jboost.examples.AttributeDescription;
import jboost.examples.ExampleDescription;
import jboost.examples.Instance;
import jboost.learner.IncompAttException;
import jboost.learner.SplitterBuilder;
import jboost.learner.Summary;

/**
 * An Alternating Tree classifier
 * 
 * @author Nigel Duffy
 */
public class AlternatingTree implements WritablePredictor, Serializable {

  /**
   * The default constructor
   * 
   * @param the
   *            root node of the tree
   */
  public AlternatingTree(PredictorNode r) {
    root = r;
  }

  /** A null constructor */
  public AlternatingTree() {
    root = null;
  }

  /** Make a prediction */
  public Prediction predict(Instance instance) throws IncompAttException {
    Prediction retval = root.predict(instance);
    return (retval);
  }

  /** Make a prediction */
  public Prediction predict(Instance instance, int numIters) throws IncompAttException {
    // return predict(instance);
    return orderPredict(instance, numIters);
  }

  /** Make a iteration orderd prediction */
  public Prediction orderPredict(Instance instance, int numIters) throws IncompAttException {
    Prediction retval = root.orderPredict(instance, numIters);
    return (retval);
  }

  /** Generate a textual explanation of the prediction */
  public String explain(Instance instance) throws IncompAttException {
    return root.explain(instance);
  }

  /**
   * Make a classification I am not sure that this function should exist.
   */
  public int classify(Instance instance) {
    return (-1);
  }

  /**
   * Convert to a human readable form.
   */
  public String toString() {
    String retval = new String("----------------------------------------------\n");
    retval += root;
    retval += "----------------------------------------------\n";
    return (retval);
  }

  /** Converts this AlternatingTree to java */
  public String toJava(String cname, String fname, String specFileName, ExampleDescription exampleDescription) throws FileNotFoundException, IOException {
    String code = "";
    tokenMap = new HashMap();
    tokenList = new Vector();
    numTokens = 0;
    maxTextAttr = 0;
    maxAttr = 0;
    realAttrs = new TreeSet();
    discreteAttrs = new TreeSet();
    textAttrs = new TreeMap();

    String fname_int = fname + "_int";

    code +=
        "" + "/**\n" + "   This class provides static methods for evaluating a jboost-trained\n"
            + "   classifier on new data.  This part of the code can stand by itself.\n" + "\n";
    if (specFileName != null) {
      code +=
          "" + "   In addition, this class includes a main which, when run, reads data\n"
              + "   from standard input of the same form as that used during training,\n"
              + "   and outputs corresponding predictions to standard output.  This\n" + "   part of the code requires other jboost classes.\n" + "\n";
    }
    code +=
        "" + "   This classifier was automatically generated by jboost on\n" + "   " + (new Date()) + ".\n" + "**/\n" + "\n" + "import java.util.*;\n" + "\n"
            + "public class " + cname + "{\n" + "\n" + "  /**\n" + "     Evaluates this classifier on an example represented by an array\n"
            + "     of Objects and returns an array of scores, one for each class.\n" + "     Finite attributes must be represented by an Integer specifying\n"
            + "     the index of the chosen value.  Text attributes are given by a\n"
            + "     String.  Number attributes are represented by a Double.  In all\n" + "     cases, an undefined attribute is indicated by a null pointer.\n"
            + "     @param at an array of Objects corresponding to the attributes\n"
            + "                   specified in the spec file on which this classifier\n" + "		   was trained.  Specifically, these objects are:\n" + "<pre>\n"
            + "  *      index    attr.type    data.type   name\n" + "  *    ------------------------------------------\n";
    AttributeDescription[] ad = exampleDescription.getAttributes();
    for (int i = 0; i < ad.length; i++) {
      String s;
      String key = "";
      String t = ad[i].getType();
      if (t.equals("number")) {
        s = "number       Double   ";
      }
      else if (t.equals("text")) {
        s = "text         String   ";
      }
      else if (t.equals("finite")) {
        s = "finite       Integer  ";
        for (int j = 0; j < ad[i].getNoOfValues(); j++)
          key += (j == 0 ? "  *                 key: " : "  *                      ") + padInteger(j, 5) + " = " + ad[i].getAttributeValue(j) + "\n";
      }
      else {
        System.err.println("Warning: unrecognized type for attribute " + i + ": " + t);
        s = "???          ???      ";
      }
      code += "  *     " + padInteger(i, 5) + "     " + s + "    " + ad[i].getAttributeName() + "\n" + key;
    }
    String label_code = "";
    label_code +=
        "" + "</pre>\n" + "     @return an array of scores correpsonding to the classes:\n" + "<pre>\n" + "  *           index       class name\n"
            + "  *          ------------------------\n";
    AttributeDescription la = exampleDescription.getLabelDescription();

    for (int j = 0; j < la.getNoOfValues(); j++)
      label_code += "  *          " + padInteger(j, 5) + "        " + la.getAttributeValue(j) + "\n";
    code +=
        label_code + "</pre>\n" + "  **/\n" + "  static public double[] predict(Object[] at) {\n" + "    attr = at;\n" + "    int i,j,a,n;\n"
            + "    StringTokenizer st;\n" + "    String s;\n" + "    Object v;\n" + "    Enumeration e;\n" + "    for (i = 0; i < num_text_attr; i++) {\n"
            + "      a = text_attr[i];\n" + "      if (!defined_attr(a))\n" + "        continue;\n" + "      Arrays.fill(tokens[a], false);\n"
            + "      try {\n" + "        s = (String) attr[a];\n" + "      }\n" + "      catch (ClassCastException ex) {\n"
            + "        throw new IllegalArgumentException\n" + "          (\"Expected attribute \" + a + \" to be of type String\");\n" + "      }\n"
            + "      st = new StringTokenizer(s);\n" + "      n = st.countTokens();\n" + "      String[] words = new String[n];\n"
            + "      for (j = 0; j < n; j++)\n" + "        words[j] = st.nextToken();\n" + "      for (j = 0; j < text_patterns[i].length; j++) {\n"
            + "        setPattern(words, text_patterns[i][j]);\n" + "        while(moreTokens())\n" + "          if ((v = hash.get(nextToken())) != null)\n"
            + "            tokens[a][((Integer) v).intValue()] = true;\n" + "      }\n" + "    }\n" + "    return " + fname_int + "();\n" + "  }\n" + "\n"
            + "  /**\n" + "     Evaluates this classifier on an example represented by an array\n"
            + "     of Strings and returns an array of scores, one for each class.\n" + "     These Strings represent the values of the attributes similar\n"
            + "     to their representation in a data file.  Null pointers can be\n" + "     passed for undefined attributes.\n" + "\n"
            + "     @param at an array of Objects corresponding to the attributes\n"
            + "                   specified in the spec file on which this classifier\n" + "		   was trained.  Specifically, these objects are:\n" + "<pre>\n"
            + "  *      index    attr.type    name\n" + "  *    ------------------------------------------\n";
    for (int i = 0; i < ad.length; i++) {
      String s;
      String key = "";
      String t = ad[i].getType();
      if (t.equals("number")) {
        s = "number       ";
      }
      else if (t.equals("text")) {
        s = "text         ";
      }
      else if (t.equals("finite")) {
        s = "finite       ";
        for (int j = 0; j < ad[i].getNoOfValues(); j++)
          key += (j == 0 ? "  *                 values: " : "  *                         ") + ad[i].getAttributeValue(j) + "\n";
      }
      else {
        System.err.println("Warning: unrecognized type for attribute " + i + ": " + t);
        s = "???          ";
      }
      code += "  *     " + padInteger(i, 5) + "     " + s + ad[i].getAttributeName() + "\n" + key;
    }
    code +=
        label_code + "</pre>\n" + "  **/\n" + "  static public double[] " + fname + "(String[] as) {\n" + "    int j, a;\n" + "    Object v;\n"
            + "    Object[] attr = new Object[as.length];\n" + "\n" + "    for (j = 0; j < real_attr.length; j++) {\n" + "      a = real_attr[j];\n"
            + "      try{ \n" + "        attr[a] = (as[a] == null || as[a].trim().equals(\"\")\n" + "                   ? null\n"
            + "                   : (new Double(as[a])));\n" + "      }\n" + "      catch (NumberFormatException e) {\n"
            + "        throw new IllegalArgumentException\n" + "             (\"Expected attribute \" + a + \" to contain a String parsable as a double\");\n"
            + "      }\n" + "    }\n" + "    for (j = 0; j < text_attr.length; j++) {\n" + "      a = text_attr[j];\n" + "      attr[a] = as[a];\n" + "    }\n"
            + "    for (j = 0; j < disc_attr.length; j++) {\n" + "      String s = null;\n" + "      a = disc_attr[j];\n"
            + "      if (as[a] == null || (s = as[a].trim()).equals(\"\"))\n" + "        attr[a] = null;\n"
            + "      else if ((v = disc_val_map[j].get(s)) == null) {\n" + "        throw new IllegalArgumentException\n"
            + "             (\"Illegal value for attribute \" + a + \":\" + s);\n" + "      } else\n" + "        attr[a] = ((Integer) v);\n" + "    }\n" + "\n"
            + "    return " + fname + "(attr);\n" + "  }\n" + "\n" + "  static private double[] " + fname_int + "() {\n" + "    reset_pred();\n"
            + makeCode(root, "    ") + "\n" + "    return finalize_pred();\n" + "  }\n";

    code += "  static private String[] keys = {\n";
    for (int i = 0; i < numTokens; i++)
      code += "             \"" + checkChar((String) tokenList.get(i)) + "\",\n";
    code +=
        "  };\n" + "  static private final int num_keys = " + numTokens + ";\n" + "  static private boolean[][] tokens = new boolean[" + (maxTextAttr + 1)
            + "][];\n" + "  static private int text_attr[] = {";
    for (Iterator i = textAttrs.keySet().iterator(); i.hasNext();)
      code += ((Integer) i.next()) + ",";
    code += "  };\n" + "  static private final int num_text_attr = " + textAttrs.size() + ";\n" + "  static private boolean[][][] text_patterns = {\n";
    for (Iterator i = textAttrs.keySet().iterator(); i.hasNext();) {
      code += "    {\n";
      for (Iterator j = ((Set) textAttrs.get(i.next())).iterator(); j.hasNext();) {
        String p = (String) j.next();
        code += "      {";
        int l = p.length();
        for (int k = 0; k < l; k++)
          code += (p.charAt(k) == '1' ? "true," : "false,");
        code += "},\n";
      }
      code += "    },\n";
    }
    code += "  };\n" + "  static private int real_attr[] = {";
    for (Iterator i = realAttrs.iterator(); i.hasNext();)
      code += ((Integer) i.next()) + ",";
    code += "  };\n" + "  static private int disc_attr[] = {";
    for (Iterator i = discreteAttrs.iterator(); i.hasNext();)
      code += ((Integer) i.next()) + ",";
    code +=
        "  };\n" + "  static private Object[] attr;\n" + "  static private Map hash = null;\n" + "  static private Map[] disc_val_map = null;\n"
            + "  static private String[][] disc_attr_vals = {\n";
    for (Iterator i = discreteAttrs.iterator(); i.hasNext();) {
      AttributeDescription a = exampleDescription.getAttributeDescription(((Integer) i.next()).intValue());
      code += "    {\n";
      for (int j = 0; j < a.getNoOfValues(); j++)
        code += "      \"" + checkChar(a.getAttributeValue(j)) + "\",\n";
      code += "    },\n";
    }
    code +=
        "" + "  };\n" + "\n" + "  static {\n" + "    disc_val_map = new Map[disc_attr.length];\n" + "    for (int i = 0; i < disc_attr.length; i++) {\n"
            + "      disc_val_map[i] = new TreeMap();\n" + "      for (int j = 0; j < disc_attr_vals[i].length; j++)\n"
            + "        disc_val_map[i].put(disc_attr_vals[i][j], new Integer(j));\n" + "    }\n" + "  }\n" + "\n" + "  static {\n"
            + "    if (hash == null) {\n" + "      hash = new HashMap();\n" + "      for (int i = 0; i < num_keys; i++)\n"
            + "        hash.put(keys[i], new Integer(i));\n" + "    }\n" + "  }\n" + "\n" + "  static{\n" + "    for (int i = 0; i < num_text_attr; i++)\n"
            + "      tokens[text_attr[i]] = new boolean[num_keys];\n" + "  }\n" + "\n" + "  static private boolean defined_attr(int i) {\n"
            + "    return (attr[i] != null);\n" + "  }\n" + "\n" + "  static private double double_attr(int i) {\n" + "    double r;\n" + "    try {\n"
            + "      r = ((Double) attr[i]).doubleValue();\n" + "    }\n" + "    catch (ClassCastException e) {\n"
            + "      throw new IllegalArgumentException\n" + "        (\"Expected attribute \" + i + \" to be of type Double\");\n" + "    }\n"
            + "    return r;\n" + "  }\n" + "\n" + "  static private int int_attr(int i) {\n" + "    int r;\n" + "    try {\n"
            + "      r = ((Integer) attr[i]).intValue();\n" + "    }\n" + "    catch (ClassCastException e) {\n" + "      throw new IllegalArgumentException\n"
            + "        (\"Expected attribute \" + i + \" to be of type Integer\");\n" + "    }\n" + "    return r;\n" + "  }\n" + "\n"
            + "  static private boolean attr_contains_token(int i, int k) {\n" + "    return tokens[i][k];\n" + "  }\n" + "\n"
            + "  static private int cur_word = 0;\n" + "  static private String[] words = null;\n" + "  static private boolean[] pattern = null;\n"
            + "  static private String prepend = \"\";\n" + "  static private final String[] prependChar = {\"0\", \"1\"};\n" + "\n"
            + "  static private void setPattern(String[] m_w, boolean[] pat) {\n" + "    words = m_w;\n" + "    pattern = pat;\n" + "    cur_word = 0;\n"
            + "    prepend = \"\";\n" + "    for (int i = 0; i < pattern.length; i++)\n" + "      prepend += prependChar[pattern[i] ? 1 : 0];\n" + "  }\n"
            + "\n" + "  static private boolean moreTokens() {\n" + "    return (cur_word <= words.length - pattern.length);\n" + "  }\n" + "\n"
            + "  static private String nextToken() {\n" + "    if (!moreTokens())\n" + "      throw new NoSuchElementException();\n"
            + "    String r = prepend;\n" + "    for (int i = 0; i < pattern.length; i++) {\n" + "      if (pattern[i])\n"
            + "        r += \" \" + words[cur_word + i];\n" + "    }\n" + "    cur_word++;\n" + "    return r;\n" + "  }\n" + "\n"
            + root.prediction.javaPreamble();
    if (specFileName != null) {
      code +=
          "" + "//------------------------- start cut here to make stand alone -----------\n" + "  static private jboost.examples.Example ex;\n" + "\n"
              + "  /**\n" + "     The main reads examples from standard input.  The examples must\n"
              + "     have the same format as used during training.  After each example\n" + "     is read a vector of scores is output, one per class.\n"
              + "  **/\n" + "  static public void main(String[] argv) {\n" + "    jboost.monitor.Monitor.logLevel = -1;\n" + "\n"
              + "    jboost.tokenizer.ExampleStream exStream = null;\n" + "\n" + "    try {\n" + "      exStream =\n"
              + "         new jboost.tokenizer.ExampleStream(\n" + "          (new jboost.tokenizer.jboost_DataStream(false, savedSpec)));\n" + "    }\n"
              + "    catch (Exception e) {\n" + "      System.err.println(\"Unable to parse spec file.\");\n" + "      e.printStackTrace();\n"
              + "      return;\n" + "    }\n" + "\n" + "    attr = new Object["
              + (maxAttr + 1)
              + "];\n"
              + "\n"
              + "    jboost.examples.TextDescription.setTokenSet(keys);\n"
              + "\n"
              + "    int i, a, j, k;\n"
              + "    double[] r;\n"
              + "\n"
              + "    while(true) {\n"
              + "      try {\n"
              + "        ex = exStream.getExample();\n"
              + "      }\n"
              + "      catch(jboost.tokenizer.ParseException e) {\n"
              + "        System.err.println(\"Bad example encountered:\");\n"
              + "        System.err.println(e.getMessage());\n"
              + "        continue;\n"
              + "      }\n"
              + "      if (ex == null)\n"
              + "        break;\n"
              + "      for (j = 0; j < real_attr.length; j++) {\n"
              + "        a = real_attr[j];\n"
              + "        jboost.examples.Attribute at = ex.getAttribute(a);\n"
              + "        attr[a] = (at.isDefined()\n"
              + "            ? (new Double(((jboost.examples.RealAttribute) at).getValue()))\n"
              + "            : null);\n"
              + "      }\n"
              + "      for (j = 0; j < disc_attr.length; j++) {\n"
              + "        a = disc_attr[j];\n"
              + "        jboost.examples.Attribute at = ex.getAttribute(a);\n"
              + "        attr[a] = (at.isDefined()\n"
              + "            ? (new Integer(((jboost.examples.DiscreteAttribute) at).getValue()))\n"
              + "            : null);\n"
              + "      }\n"
              + "      for (j = 0; j < text_attr.length; j++) {\n"
              + "        a = text_attr[j];\n"
              + "        jboost.examples.Attribute at = ex.getAttribute(a);\n"
              + "        if (at.isDefined()) {\n"
              + "          attr[a] = \"\";\n"
              + "          int[] set = ((jboost.examples.SetAttribute) ex.getAttribute(a)).getList();\n"
              + "\n"
              + "          Arrays.fill(tokens[a], false);\n"
              + "          for (k = 0; k < set.length; k++) {\n"
              + "            tokens[a][set[k]] = true;\n"
              + "          }\n"
              + "        } else\n"
              + "          attr[a] = null;\n"
              + "      }\n"
              + "\n"
              + "      r = "
              + fname_int
              + "();\n"
              + "      for(j = 0; j < r.length; j++)\n"
              + "        System.out.print(r[j] + \" \");\n"
              + "      System.out.println();\n"
              + "    }\n"
              + "  }\n"
              + "\n"
              + "  private static final String savedSpec = \"";

      BufferedReader spec = new BufferedReader(new FileReader(specFileName));
      final int buflen = 1000;
      char[] cbuf = new char[buflen];
      int i, n;
      while ((n = spec.read(cbuf, 0, buflen)) != -1)
        for (i = 0; i < n; i++)
          code += checkChar(cbuf[i]);
      code += "\";\n" + "//--------------------------- end cut ------------------------------------\n";

    }

    code += "\n}\n";
    tokenMap = null; // free memory
    tokenList = null;
    realAttrs = null;
    discreteAttrs = null;
    textAttrs = null;
    return code;
  }

  /**
   * Converts this AlternatingTree to C
   */
  public String toC(String fname, ExampleDescription exampleDescription) {
    String preamble = "";
    String code = "";
    tokenMap = new HashMap();
    tokenList = new Vector();
    numTokens = 0;
    maxTextAttr = 0;
    realAttrs = discreteAttrs = null;
    textAttrs = new TreeMap();
    int hashTableSize = -1;

    preamble +=
        "" + "/*************************************\n" + "This program can be used to evaluate a jboost-trained classifier on new data.  \n"
            + "The code contains a single procedure:\n" + "\n" + "  double " + fname + "(void **attr, double *ret)\n" + "\n"
            + "The first argument attr is an array of pointers corresponding to the\n"
            + "attributes specified in the spec file.  Thus, if attribute i is text,\n"
            + "then attr[i] must be a char array; if attribute i is a number, then\n"
            + "*attr[i] must be a double; and if attribute i is finite, then *attr[i]\n"
            + "must be an int containing the index of the chosen value.  An undefined\n" + "attribute is indicated by setting attr[i] to NULL.\n" + "\n"
            + "Specifically, these pointers are:\n" + "\n" + "     index    attr.type    data.type   name\n"
            + "   ------------------------------------------\n";
    AttributeDescription[] ad = exampleDescription.getAttributes();
    for (int i = 0; i < ad.length; i++) {
      String s;
      String key = "";
      String t = ad[i].getType();
      if (t.equals("number")) {
        s = "number       double  ";
      }
      else if (t.equals("text")) {
        s = "text         char    ";
      }
      else if (t.equals("finite")) {
        s = "finite       int     ";
        for (int j = 0; j < ad[i].getNoOfValues(); j++)
          key += (j == 0 ? "                   key: " : "                        ") + padInteger(j, 5) + " = " + ad[i].getAttributeValue(j) + "\n";
      }
      else {
        System.err.println("Warning: unrecognized type for attribute " + i + ": " + t);
        s = "???          ???     ";
      }
      preamble += "    " + padInteger(i, 5) + "     " + s + "    " + ad[i].getAttributeName() + "\n" + key;
    }
    preamble +=
        "" + "\n" + "The second argument ret is a pointer to an array of k doubles, where k\n"
            + "is the number of classes.  The scores for each of the k classes will\n"
            + "be stored in this array.  If ret is NULL, then no scores are stored.\n" + "In any case, predict returns the score for class 0 (=ret[0]).\n"
            + "\n" + "These scores correspond to the classes as follows:\n" + "\n" + "            index       class name\n"
            + "           ------------------------\n";
    AttributeDescription la = exampleDescription.getLabelDescription();
    for (int j = 0; j < la.getNoOfValues(); j++)
      preamble += "           " + padInteger(j, 5) + "        " + la.getAttributeValue(j) + "\n";
    preamble +=
        "" + "\n" + "This classifier was automatically generated by jboost on\n" + (new Date()) + ".\n" + "*************************************/\n"
            + "#include <stdio.h>\n" + "#include <stdlib.h>\n" + "#include <strings.h>\n" + "#include <values.h>\n" + root.prediction.cPreamble()
            + "#define defined_attr(X)  (attr[X])\n" + "#define int_attr(X)      (*((int *) attr[X]))\n" + "#define attr_contains_token(X,Y) (tokens[X][Y])\n"
            + "#define double_attr(X)   (*((double *) attr[X]))\n\n" + "#define WHITE_CHARS   \" \\t\\n\"\n" + "typedef struct hash_table_entry_s {\n"
            + "  char *key;\n" + "  int id;\n" + "  struct hash_table_entry_s *next;\n" + "} HashTableEntry_t;\n";

    code +=
        "\n" + "static char **words;\n" + "static int num_words;\n" + "static int cur_word;\n" + "static char *pattern;\n" + "static int pattern_len;\n" + "\n"
            + "static void set_pattern(int n, char **m_w, char *pat) {\n" + "  words = m_w;\n" + "  pattern = pat;\n" + "  cur_word = 0;\n"
            + "  num_words = n;\n" + "  pattern_len = strlen(pat);\n" + "}\n" + "\n" + "#define more_tokens()  (cur_word <= num_words - pattern_len)\n" + "\n"
            + "#define ADD_CHAR(S)  { \\\n" + "  if (c >= buffer_size) { \\\n" + "    buffer_size = 2 * buffer_size + 1; \\\n"
            + "    buffer = (char *) realloc(buffer, buffer_size * sizeof(char)); \\\n" + "  } \\\n" + "  buffer[c++] = (S); \\\n" + "}\n" + "\n"
            + "static char *next_token(void) {\n" + "  static char *buffer = NULL;\n" + "  static int buffer_size = 0;\n" + "  int i, c;\n" + "  char *s;\n"
            + "\n" + "  c = 0;\n" + "  for (s = pattern; *s; s++)\n" + "    ADD_CHAR(*s);\n" + "\n" + "  for (i = 0; i < pattern_len; i++) {\n"
            + "    if (pattern[i] == '1') {\n" + "      ADD_CHAR(' ');\n" + "      for (s = words[cur_word + i]; *s; s++)\n" + "	ADD_CHAR(*s);\n" + "    }\n"
            + "  }\n" + "  ADD_CHAR('\\0');\n" + "  cur_word++;\n" + "  return buffer;\n" + "}\n" + "\n" + "static int\n" + "hash(char *s) {\n"
            + "  static int *coef = NULL;\n" + "  static int max_len = 0;\n" + "  int len = strlen(s);\n" + "  int i, h;\n\n" + "  if (len > max_len) {\n"
            + "    i = max_len;\n" + "    max_len = 2 * len;\n" + "    coef = (int *) realloc(coef, max_len * sizeof(int));\n"
            + "    for (; i < max_len; i++)\n" + "      coef[i] = random() % hash_table_size;\n" + "  }\n\n" + "  h = 0;\n" + "  for (i = 0; i < len; i++) {\n"
            + "     if (h >= MAXINT - (hash_table_size - 1) * 255)\n" + "       h = h % hash_table_size;\n" + "     h += coef[i] * s[i];\n" + "  }\n"
            + "  return (h % hash_table_size);\n" + "}\n\n" + "double "
            + fname
            + "(void **attr, double *r) {\n"
            + "  int i, j, h, a;\n"
            + "  HashTableEntry_t *entry;\n"
            + "  char *s;\n"
            + "  static char **words = NULL;\n"
            + "  static int max_word_list_size = 0;\n"
            + "  int num_words;\n"
            + "  static char *buffer = NULL;\n"
            + "  static int buffer_size = 0;\n"
            + "  char **pat;\n"
            + "\n"
            + "  Prediction_t p;\n"
            + "\n"
            + "  if (!hash_table) {\n"
            + "    hash_table = (HashTableEntry_t **)\n"
            + "      malloc(hash_table_size * sizeof(HashTableEntry_t *));\n"
            + "    for (i = 0; i < hash_table_size; i++)\n"
            + "      hash_table[i] = NULL;\n"
            + "    for (i = 0; i < num_keys; i++) {\n"
            + "      h = hash(keys[i]);\n"
            + "      entry = (HashTableEntry_t *) malloc(sizeof(HashTableEntry_t));\n"
            + "      entry->key = keys[i];\n"
            + "      entry->id = i;\n"
            + "      entry->next = hash_table[h];\n"
            + "      hash_table[h] = entry;\n"
            + "    }\n"
            + "    for (i = 0; i < num_text_attr; i++)\n"
            + "      tokens[text_attr[i]] = (char *) malloc(num_keys * sizeof(char));\n"
            + "  }\n"
            + "\n"
            + "  for (i = 0; i < num_text_attr; i++) {\n"
            + "    a = text_attr[i];\n"
            + "    if (!defined_attr(a))\n"
            + "      continue;\n"
            + "    for (j = 0; j < num_keys; j++)\n"
            + "      tokens[a][j] = 0;\n"
            + "\n"
            + "    while (strlcpy(buffer, attr[a], buffer_size) >= buffer_size) {\n"
            + "      buffer_size = 2 * strlen(attr[a]);\n"
            + "      buffer = (char *) realloc(buffer, (buffer_size+1) * sizeof(char));\n"
            + "    }\n"
            + "    num_words = 0;\n"
            + "    for (s = strtok(buffer, WHITE_CHARS); s; s = strtok(NULL, WHITE_CHARS)) {\n"
            + "      if (num_words >= max_word_list_size) {\n"
            + "        max_word_list_size = 2 * max_word_list_size + 1;\n"
            + "        words = (char **) realloc(words, max_word_list_size * sizeof(char *));\n"
            + "      }\n"
            + "      words[num_words++] = s;\n"
            + "    }\n"
            + "    for (pat = text_patterns[i]; *pat; pat++) {\n"
            + "      set_pattern(num_words, words, *pat);\n"
            + "      while (more_tokens()) {\n"
            + "        s = next_token();\n"
            + "        for (entry = hash_table[hash(s)]; entry; entry = entry->next)\n"
            + "          if (!strcmp(entry->key, s)) {\n"
            + "            tokens[a][entry->id] = 1;\n"
            + "            break;\n"
            + "          }\n"
            + "        }\n"
            + "      }\n"
            + "  }\n"
            + "\n"
            + "  reset_pred();\n\n" + makeCode(root, "  ") + "\n" + "  return finalize_pred();\n" + "}\n";

    for (int i = 0; i < primes.length && 3 * numTokens > (hashTableSize = primes[i]); i++)
      ;

    preamble += "static char *keys[] = {\n";
    for (int i = 0; i < numTokens; i++)
      preamble += "             \"" + checkChar((String) tokenList.get(i)) + "\",\n";
    preamble +=
        "};\n" + "#define num_keys  (" + numTokens + ")\n" + "static HashTableEntry_t **hash_table = NULL;\n" + "#define hash_table_size  (" + hashTableSize
            + ")\n" + "static char *tokens[" + (maxTextAttr + 1) + "];\n" + "static int text_attr[] = {";
    for (Iterator i = textAttrs.keySet().iterator(); i.hasNext();)
      preamble += ((Integer) i.next()) + ",";
    preamble += "};\n" + "#define num_text_attr  (" + textAttrs.size() + ")\n";
    int c = 0;
    for (Iterator i = textAttrs.keySet().iterator(); i.hasNext();) {
      preamble += "static char *text_pat_" + c + "[] = {";
      for (Iterator j = ((Set) textAttrs.get(i.next())).iterator(); j.hasNext();) {
        preamble += "\"" + j.next() + "\",";
      }
      preamble += "NULL};\n";
      c++;
    }
    preamble += "static char **text_patterns[] = {\n";
    for (int i = 0; i < c; i++)
      preamble += "  text_pat_" + i + ",\n";
    preamble += "};\n";

    tokenMap = null; // free memory
    tokenList = null;
    textAttrs = null;
    return preamble + code;
  }

  private Map tokenMap; // maps text strings to tokens
  private Vector tokenList; // maps tokens to text strings
  private int numTokens; // number of tokens added to map so far
  private int maxTextAttr; // maximum index of any used text attribute
  private int maxAttr; // maximum index of any used attribute
  private Map textAttrs; // indices of all used text attributes
  // mapped to ngram patterns with which they occur
  private Set realAttrs; // indices of all used real attributes
  private Set discreteAttrs; // indices of all used discrete attributes
  private static final int[] primes = { 1031, 2053, 4099, 8209, 16411, 32771, 65537, 131101, 262147, 524309, 1048583, 2097169, 4194319 };

  private String makeCode(PredictorNode pn, String tab) {
    String code = "";
    code += tab + "add_pred(   /* " + pn.id + " */\n";
    double[] v = pn.prediction.toCodeArray();
    for (int i = 0; i < v.length; i++)
      code += tab + "           " + v[i] + (i < v.length - 1 ? ",\n" : ");\n");
    int size = pn.splitterNodes.size();
    for (int i = 0; i < size; i++)
      code += makeCode((SplitterNode) pn.splitterNodes.get(i), tab);
    return code;
  }

  private String makeCode(SplitterNode sn, String tab) {
    String code = "";

    Summary summary = sn.splitter.getSummary();

    code += tab + "if (defined_attr(" + summary.index + ")) {  /* " + sn.id + " */\n";
    switch (summary.type) {
      case Summary.EQUALITY:
        code += tab + "  if (int_attr(" + summary.index + ") == " + ((Integer) summary.val) + ") {\n";
        code += makeCode(sn.predictorNodes[0], tab + "    ");
        code += tab + "  } else {\n";
        code += makeCode(sn.predictorNodes[1], tab + "    ");
        code += tab + "  }\n";
        code += tab + "}\n";
        if (discreteAttrs != null) discreteAttrs.add(new Integer(summary.index));
        break;
      case Summary.LESS_THAN:
        code += tab + "  if (double_attr(" + summary.index + ") <= " + ((Double) summary.val) + ") {\n";
        code += makeCode(sn.predictorNodes[0], tab + "    ");
        code += tab + "  } else {\n";
        code += makeCode(sn.predictorNodes[1], tab + "    ");
        code += tab + "  }\n";
        code += tab + "}\n";
        if (realAttrs != null) realAttrs.add(new Integer(summary.index));
        break;
      case Summary.CONTAINS_ABSTAIN:
      case Summary.CONTAINS_NOABSTAIN:
        String s = (String) summary.val;
        if (!tokenMap.containsKey(s)) {
          tokenMap.put(s, new Integer(numTokens++));
          tokenList.add(s);
        }

        Integer idx = new Integer(summary.index);
        if (!textAttrs.containsKey(idx)) textAttrs.put(idx, new TreeSet());
        String p = (new StringTokenizer(s)).nextToken();
        ((TreeSet) textAttrs.get(idx)).add(p);

        if (summary.index > maxTextAttr) maxTextAttr = summary.index;

        code += tab + "  if (attr_contains_token(" + summary.index + ", " + (Integer) tokenMap.get(s) + ")) {\n";
        code += makeCode(sn.predictorNodes[0], tab + "    ");
        if (summary.type == Summary.CONTAINS_NOABSTAIN) {
          code += tab + "  } else {\n";
          code += makeCode(sn.predictorNodes[1], tab + "    ");
        }
        code += tab + "  }\n";
        code += tab + "}\n";
        break;
      default:
        throw new RuntimeException("Type of split not allowed");
    }

    if (summary.index > maxAttr) maxAttr = summary.index;
    return code;
  }

  /** true if should assume all attributes are defined in Matlab code */
  private boolean allDefined = false;

  /** Description of all attributes */
  private AttributeDescription[] ad = null;

  /**
   * Converts this AlternatingTree to Matlab. Assumes that all attributes are of
   * type number or finite. If allDefined = true then all attributes are assumed
   * to be defined.
   */
  public String toPython(String fname, ExampleDescription exampleDescription) {
    allDefined = true;
    String code = "";
    code += "# The map from index to spec file description is:\n\n";
    code += "#      index    attr.type    data.type   name\n" + "#    ------------------------------------------\n";
    ad = exampleDescription.getAttributes();
    for (int i = 0; i < ad.length; i++) {
      String s;
      String key = "";
      String t = ad[i].getType();
      if (t.equals("number")) {
        s = "number       Double   ";
      }
      else if (t.equals("text")) {
        s = "text         String   ";
      }
      else if (t.equals("finite")) {
        s = "finite       Integer  ";
        for (int j = 0; j < ad[i].getNoOfValues(); j++)
          key += (j == 0 ? "#                 key: " : "#                      ") + padInteger(j, 5) + " = " + ad[i].getAttributeValue(j) + "\n";
      }
      else {
        System.err.println("Warning: unrecognized type for attribute " + i + ": " + t);
        s = "???          ???      ";
      }
      code += "#     " + padInteger(i, 5) + "     " + s + "    " + ad[i].getAttributeName() + "\n" + key;
    }
    code +=
        "" + "#return an array of scores correpsonding to the classes:\n" + "#           index       class name\n" + "#          ------------------------\n";
    AttributeDescription la = exampleDescription.getLabelDescription();

    for (int j = 0; j < la.getNoOfValues(); j++)
      code += "#          " + padInteger(j, 5) + "        " + la.getAttributeValue(j) + "\n";

    code +=
        "\n\n" + "# This class evaluates a jboost-trained classifier.  The "
            + (allDefined ? "" : "first ")
            + "\n"
            + "# argument is an array of values corresponding to the formatted data\n"
            + "# used during training."
            + (allDefined ? "\n" : "  The second argument is an array of values\n" + "# indicating which of the attributes are defined (where non-zero means\n"
                                   + "# that the corresponding attribute is defined).\n") + "# This classifier was automatically generated by jboost on:\n"
            + "# " + (new Date()) + "\n" + "class ATree:\n" + "\t\"\"\"\n" + "\tThe ATree class provides access to scoring algorithms"
            + "\tderived from an ATree data structure.  This class only\n" + "\tprovides scores and does not learn the structure.\n" + "\t\"\"\"\n" + "\t\n"
            + "\tdef __init__(self, datafile, specfile):\n" + "\t\tself.datafile = datafile\n" + "\t\tself.specfile = specfile\n"
            + "\t\tself.data = self.__read_in_data()\n" + "\t\tself.spec_dict = self.__read_in_spec()\n" + "\t\n" + "\tdef get_scores(self):\n"
            + "\t\tret = []\n" + "\t\tfor i,x in enumerate(self.data):\n" + "\t\t\tret.append(self.__score(i))\n" + "\t\treturn ret\n" + "\t\n"
            + "\tdef __score(self, i):\n" + "\t\treturn self.__predict(i)\n" + "\t\n" + "\tdef get_data_value(self, x, feature):\n"
            + "\t\tidx = self.spec_dict[feature]\n" + "\t\treturn float(x[idx])\n" + "\t\n" + "\tdef __read_in_data(self):\n" + "\t\t\"\"\"\n"
            + "\t\tReads in the datafile.\n" + "\t\t\"\"\"\n" + "\t\tf = open(self.datafile)\n" + "\t\tlines = f.readlines()\n" + "\t\tf.close()\n"
            + "\t\tret = []\n" + "\t\tfor line in lines:\n" + "\t\t\tline = line[:-2]\n" + "\t\t\tret.append([x.strip() for x in line.split(',')])\n"
            + "\t\treturn ret\n" + "\t\n" + "\tdef __read_in_spec(self):\n" + "\t\t\"\"\"\n" + "\t\tReturns a dictionary with feature names => data index\n"
            + "\t\t\"\"\"\n" + "\t\tf = open(self.specfile)\n" + "\t\tlines = f.readlines()\n" + "\t\tf.close()\n" + "\t\tret = {}\n" + "\t\ti = 0\n"
            + "\t\tfor line in lines:\n" + "\t\t\tif '=' in line:\n" + "\t\t\t\tcontinue\n" + "\t\t\tdescription = line.split()[0]\n"
            + "\t\t\tret[description] = i\n" + "\t\t\ti += 1\n" + "\t\treturn ret\n" + "\t\n" + "\tdef __predict(self, i" + (allDefined ? "" : ", def")
            + "):\n" + "\t\tx=self.data[i]\n" + "\t\tpred = [0  for i in range(" + root.prediction.toCodeArray().length + ")]\n" + makePythonCode(root, "\t\t")
            + "\t\treturn pred" + "\n" + "\n" + "import sys\n" + "def main():\n" + "\tdatafile = sys.argv[1]\n" + "\tspecfile = sys.argv[2]\n"
            + "\tatree = ATree(datafile, specfile)\n" + "\tscores = atree.get_scores()\n" + "\tprint scores\n" + "if __name__=='__main__':\n" + "\tmain()\n"
            + "\n" + "\n";
    return code;
  }

  private String makePythonCode(PredictorNode pn, String tab) {
    String code = "";
    code += tab + "newpred = [ # " + pn.id + "\n";
    double[] v = pn.prediction.toCodeArray();
    for (int i = 0; i < v.length; i++)
      code += tab + "           " + v[i] + (i < v.length - 1 ? "\n" : "]\n");
    code += tab + "pred = [n+p for n,p in zip(newpred,pred)]\n";
    int size = pn.splitterNodes.size();
    for (int i = 0; i < size; i++)
      code += makePythonCode((SplitterNode) pn.splitterNodes.get(i), tab);
    return code;
  }

  private String makePythonCode(SplitterNode sn, String tab) {
    String code = "";

    Summary summary = sn.splitter.getSummary();

    code += tab + (allDefined ? "    " : "if def(" + (summary.index + 1) + "):") + " # " + sn.id + "\n";
    String stab = (allDefined ? tab : tab);
    switch (summary.type) {
      case Summary.EQUALITY:
        code += stab + "if self.get_data_value(x,'" + ad[(summary.index)].getAttributeName() + "') == " + ((Integer) summary.val) + ":\n";
        code += makeMatlabCode(sn.predictorNodes[0], stab + "\t");
        code += stab + "else:\n";
        code += makeMatlabCode(sn.predictorNodes[1], stab + "\t");
        break;
      case Summary.LESS_THAN:
        code += stab + "if self.get_data_value(x,'" + ad[(summary.index)].getAttributeName() + "') <= " + ((Double) summary.val) + ":\n";
        code += makePythonCode(sn.predictorNodes[0], stab + "\t");
        code += stab + "else:\n";
        code += makePythonCode(sn.predictorNodes[1], stab + "\t");
        break;
      default:
        throw new RuntimeException("Type of split not allowed");
    }

    return code;
  }

  /**
   * Converts this AlternatingTree to Matlab. Assumes that all attributes are of
   * type number or finite. If allDefined = true then all attributes are assumed
   * to be defined.
   */
  public String toMatlab(String fname, ExampleDescription exampleDescription) {
    String code = "";
    code +=
        ""
            + "% This function evaluates a jboost-trained classifier.  The "
            + (allDefined ? "" : "first ")
            + "\n"
            + "% argument is an array of values corresponding to the formatted data\n"
            + "% used during training."
            + (allDefined ? "\n" : "  The second argument is an array of values\n" + "% indicating which of the attributes are defined (where non-zero means\n"
                                   + "% that the corresponding attribute is defined).\n") + "% This classifier was automatically generated by jboost on:\n"
            + "% " + (new Date()) + "\n" + "function pred = " + fname + "(val" + (allDefined ? "" : ", def") + ")\n" + "  pred = zeros(["
            + root.prediction.toCodeArray().length + ",1]);\n" + makeMatlabCode(root, "  ") + "\n";
    return code;
  }

  private String makeMatlabCode(PredictorNode pn, String tab) {
    String code = "";
    code += tab + "pred = pred + [   % " + pn.id + "\n";
    double[] v = pn.prediction.toCodeArray();
    for (int i = 0; i < v.length; i++)
      code += tab + "           " + v[i] + (i < v.length - 1 ? "\n" : "];\n");
    int size = pn.splitterNodes.size();
    for (int i = 0; i < size; i++)
      code += makeMatlabCode((SplitterNode) pn.splitterNodes.get(i), tab);
    return code;
  }

  private String makeMatlabCode(SplitterNode sn, String tab) {
    String code = "";

    Summary summary = sn.splitter.getSummary();

    code += tab + (allDefined ? "    " : "if def(" + (summary.index + 1) + ")") + " % " + sn.id + "\n";
    String stab = (allDefined ? tab : tab + "  ");
    switch (summary.type) {
      case Summary.EQUALITY:
        code += stab + "if val(" + (summary.index + 1) + ") == " + ((Integer) summary.val) + "\n";
        code += makeMatlabCode(sn.predictorNodes[0], stab + "  ");
        code += stab + "else\n";
        code += makeMatlabCode(sn.predictorNodes[1], stab + "  ");
        code += stab + "end\n";
        if (!allDefined) code += tab + "end\n";
        break;
      case Summary.LESS_THAN:
        code += stab + "if val(" + (summary.index + 1) + ") <= " + ((Double) summary.val) + "\n";
        code += makeMatlabCode(sn.predictorNodes[0], stab + "  ");
        code += stab + "else\n";
        code += makeMatlabCode(sn.predictorNodes[1], stab + "  ");
        code += stab + "end\n";
        if (!allDefined) code += tab + "end\n";
        break;
      default:
        throw new RuntimeException("Type of split not allowed");
    }

    return code;
  }

  /**
   * puts leading white space to pad an integer n to have a uniform length l.
   */
  private String padInteger(int n, int l) {
    String s = "" + n;
    for (int i = s.length(); i < l; i++)
      s = " " + s;
    return s;
  }

  /**
   * converts a character or string to format appropriate to include in a C or
   * java file.
   */
  private String checkChar(char c) {
    switch (c) {
      case '\b':
        return "\\b";
      case '\t':
        return "\\t";
      case '\n':
        return "\\n";
      case '\f':
        return "\\f";
      case '\r':
        return "\\r";
      case '\"':
        return "\\\"";
      case '\'':
        return "\\\'";
      case '\\':
        return "\\";
      default:
        return "" + c;
    }
  }

  private String checkChar(String s) {
    String r = "";
    for (int i = 0; i < s.length(); i++)
      r += checkChar(s.charAt(i));
    return r;
  }

  public PredictorNode getRoot() {
    return root;
  }

  /**
   * Walk through this tree and create lists of the predictor and splitter nodes
   * The lists passed to this method will be updated XXX: should this method
   * clone the nodes it copies into the lists?
   * 
   * @param predictors
   *            the list of PredictorNodes from this tree
   * @param splitters
   *            the list of SplitterNodes from this tree
   */
  public void getNodes(ArrayList predictors, ArrayList splitters) {
    if (predictors == null || splitters == null) {
      throw new IllegalArgumentException("Can not use null lists.");
    }

    Stack stack = new Stack();
    PredictorNode node = getRoot();
    stack.push(node);

    while (!stack.empty()) {
      // add the next node from the stack to the list
      node = (PredictorNode) stack.pop();
      predictors.add(node);

      // add each predictor from each splitter to the stack
      // add each splitter to the list of splitters
      for (int i = 0; i < node.getSplitterNodeNo(); i++) {
        SplitterNode splitter = (SplitterNode) node.getSplitterNodes().get(i);
        splitters.add(splitter);

        for (int j = 0; j < splitter.getPredictorNodes().length; j++) {
          stack.push(splitter.getPredictorNodes()[j]);
        }
      }
    }

  }

  /** The root node of the Tree */
  protected PredictorNode root;

  /**
   * Creates an InstrumentedAlternatingTree from this AlternatingTree by
   * creating the appropriate internal data structures.
   */
  public ComplexLearner instrument(SplitterBuilder[] sb, Booster booster) {

    return (null);

  }

}

class NodeDescription implements Comparable {

  int no;
  public String desc;

  public NodeDescription(int i, String d) {
    no = i;
    desc = d;
  }

  public int compareTo(Object o) throws ClassCastException {
    NodeDescription nd = (NodeDescription) o;
    return (no - nd.no);
  }
}
