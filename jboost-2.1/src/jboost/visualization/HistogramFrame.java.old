package jboost.visualization;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.TreeMap;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.JList;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSlider;
import javax.swing.JSplitPane;
import javax.swing.SwingUtilities;
import javax.swing.WindowConstants;
import javax.swing.border.BevelBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.filechooser.FileFilter;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.event.MarkerChangeListener;
import org.jfree.chart.plot.CombinedDomainXYPlot;
import org.jfree.chart.plot.DatasetRenderingOrder;
import org.jfree.chart.plot.IntervalMarker;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.ValueMarker;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.StandardXYItemRenderer;
import org.jfree.chart.renderer.xy.XYBarRenderer;
import org.jfree.data.xy.XYDataset;
import org.jfree.data.xy.XYIntervalSeries;
import org.jfree.data.xy.XYIntervalSeriesCollection;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import org.jfree.ui.Layer;


/**
 * This code was edited or generated using CloudGarden's Jigloo
 * SWT/Swing GUI Builder, which is free for non-commercial
 * use. If Jigloo is being used commercially (ie, by a corporation,
 * company or business for any purpose whatever) then you
 * should purchase a license for each developer using Jigloo.
 * Please visit www.cloudgarden.com for details.
 * Use of Jigloo implies acceptance of these licensing terms.
 * A COMMERCIAL LICENSE HAS NOT BEEN PURCHASED FOR
 * THIS MACHINE, SO JIGLOO OR THIS CODE CANNOT BE USED
 * LEGALLY FOR ANY CORPORATE OR COMMERCIAL PURPOSE.
 */
/**
 * @author yoavfreund (Rewritten by Sunsern Cheamanunkul)
 * 
 * A class based on swing and jFreeChart that implements a frame for visualizing an ROC and a histogram
 * for a two-class distribution or multi-class. Used to visualize the scores distribution generated by boosting.
 */
public class HistogramFrame extends javax.swing.JFrame {

  private static final long serialVersionUID = 2L;

  private JSplitPane jSplitPane1;
  private JSplitPane jSplitPane2;

  private JPanel jPanel1;
  private JPanel jPanel2;
  private JPanel jPanel3;

  private JSlider jSlider1;
  private JSlider jSlider2;

  private JMenu jMenu1;
  private JMenu jMenu2;
  private JMenuBar jMenuBar1;
  private JMenuItem jMenuItem6;
  private JMenuItem jMenuItem5;
  private JMenuItem jMenuItem4;
  private JMenuItem jMenuItem3;
  private JMenuItem jMenuItem2;
  private JMenuItem jMenuItem1;


  private JComboBox jComboBox1;
  private JScrollPane jScrollPane1;
  private JList jList1;

  private final int posLabel=+1;
  private final int negLabel=-1;

  private final int noOfBins=100;

  private XYIntervalSeriesCollection histogramDataset;
  private XYIntervalSeriesCollection fluctDataset;
  private XYSeriesCollection weightDataset;
  private XYSeriesCollection potentialDataset;

  private JFreeChart histogramChart;
  private ChartPanel histogramPanel;
  private XYSeriesCollection rocDataset;
  private JFreeChart rocChart;
  private ChartPanel rocPanel;

  private String[] iterNoList;
  private double[] averageTime;
  private double[] stdTime;
  private int iter;  //number of current iteration

  private double upper_limit, lower_limit;
  private double upperMarkerScore, lowerMarkerScore;
  private IntervalMarker histMarker;

  private ValueMarker lower_tprMarker, lower_fprMarker;  //markers for ROC graph
  private ValueMarker upper_tprMarker, upper_fprMarker;  //markers for ROC graph

  private DataSet[] allData;  // all dataset. In binary case, this has 1 element. 
  private int currentDataSet; // current dataset index
  private DataSet rawData;    // current dataset that is showing

  private int maxNumIndices, maxNumIter, numClasses;
  private boolean hasIndex, useCV, showPotential = false, showWeight = false;
  private int switchLabel = -1;
  private final int label_offset = 1; // first label 

  private boolean isRobustBoost, confRated;
  private double epsilon, theta, sigma_f, rho;

  private static boolean carryOver;
  
  private static String[] testFiles = null;
  private static String[] trainFiles = null;
  private static String[] infoFiles = null;


  public static void main(String[] args) {

    if (args.length == 0) {
      System.out.println("Please call this from the python wrapper instead");
      System.exit(-1);
    }

    if (Integer.parseInt(args[0]) != 0) {
      carryOver = true;
    }
    
    int offset = 1;

    int numTestFiles = Integer.parseInt(args[offset++]);
    testFiles = new String[numTestFiles];

    if (numTestFiles == 0) {
      System.out.println("Error: Cannot find *.test.boosting.info");
      System.exit(-1);
    }

    for (int i=0;i<numTestFiles;i++) testFiles[i] = args[offset+i];

    offset = offset + numTestFiles;

    int numTrainFiles = Integer.parseInt(args[offset++]);
    trainFiles = new String[numTrainFiles];

    for (int i=0;i<numTrainFiles;i++) trainFiles[i] = args[offset+i];

    offset = offset + numTrainFiles;

    int numInfoFiles = Integer.parseInt(args[offset++]);
    infoFiles = new String[numInfoFiles];

    for (int i=0;i<numInfoFiles;i++) infoFiles[i] = args[offset+i];
    
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        try {
          HistogramFrame inst = new HistogramFrame(testFiles, trainFiles);
          inst.setLocationRelativeTo(null);
          inst.setVisible(true);
        }
        catch (IOException e) {
          e.printStackTrace();
        }
        catch (RuntimeException e) {
          e.printStackTrace();
          System.exit(-1);
        }
      }
    });
  }

  public HistogramFrame(String[] testFiles, String[] trainFiles) throws IOException {

    super();
    
    getHasIndexAndNumClasses();
    getMaxNumIndices();
    getMaxNumIter();
    getRobustBoostInfo();
    allData = createDataSet();
    currentDataSet = 0;
    rawData = allData[currentDataSet];
    lower_limit=rawData.getMin(0);
    upper_limit=rawData.getMax(0);
    this.iterNoList = rawData.getIterList();
    initGUI();

  } 


  private void initGUI() {

    post("Intializing GUI...");

    try {
      setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
      {
        jMenuBar1 = new JMenuBar();
        setJMenuBar(jMenuBar1);
        jMenuBar1.add(getJMenu1());
        jMenuBar1.add(getJMenu2());
      }
      {
        jSplitPane2 = new JSplitPane();
        jSplitPane2.setBorder(BorderFactory.createEtchedBorder(BevelBorder.LOWERED));
        jSplitPane2.setDividerLocation(850);
        jSplitPane2.setFocusCycleRoot(true);
        jSplitPane2.add(getJSplitPane1(), JSplitPane.LEFT);
        jSplitPane2.add(getJPanel3(), JSplitPane.RIGHT);
      }

      this.add(jSplitPane2);
      pack();
      this.setSize(1000, 500);
    } catch (Exception e) {
      e.printStackTrace();
    }
  }



  private JSplitPane getJSplitPane1() {
    if(jSplitPane1 == null) {
      jSplitPane1 = new JSplitPane();
      jSplitPane1.setPreferredSize(new Dimension(546, 400));
      jSplitPane1.setDividerLocation(400);
      jSplitPane1.setDoubleBuffered(true);
      jSplitPane1.setLastDividerLocation(100);
      {
        jPanel1 = new JPanel();
        jSplitPane1.add(jPanel1, JSplitPane.RIGHT);
        jPanel1.setPreferredSize(new Dimension(10, 406));

        BoxLayout jPanel1Layout = new BoxLayout(jPanel1, javax.swing.BoxLayout.Y_AXIS);
        jPanel1.setLayout(jPanel1Layout);
        {
          histogramDataset = new XYIntervalSeriesCollection();
          fluctDataset = new XYIntervalSeriesCollection();
          weightDataset = new XYSeriesCollection();
          potentialDataset = new XYSeriesCollection();

          updateHistogramDatasets();
          histogramChart = createHistogramChart();

          histogramPanel = new ChartPanel(histogramChart);
          jPanel1.add(histogramPanel);
          histogramPanel.setPopupMenu(null);
          histogramPanel.setPreferredSize(new Dimension(433, 374));
        }
      }
      {
        jPanel2 = new JPanel();
        jSplitPane1.add(jPanel2, JSplitPane.LEFT);
        jPanel2.setPreferredSize(new Dimension(10, 393));

        BoxLayout jPanel2Layout = new BoxLayout(jPanel2, javax.swing.BoxLayout.Y_AXIS);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2.setOpaque(false);

        rocDataset = new XYSeriesCollection();
        XYSeries rocSeries = rawData.generateRoC(negLabel,posLabel);
        rocDataset.addSeries(rocSeries);
        rocChart = createRocChart(rocDataset);
        rocPanel = new ChartPanel(rocChart);
        jPanel2.add(rocPanel);
        rocPanel.setPopupMenu(null);
        rocPanel.setPreferredSize(new Dimension(10, 406));
      }
      {
        jSlider1 = new JSlider();
        jPanel1.add(jSlider1);
        jSlider1.setLayout(null);
        jSlider1.setPreferredSize(new Dimension(10, 16));
        jSlider1.addChangeListener(new ChangeListener() {
          public void stateChanged(ChangeEvent evt) {
            updateUpperMarker();
          }
        });
      }
      {
        jSlider2 = new JSlider();
        jPanel1.add(jSlider2);
        jSlider2.setLayout(null);
        jSlider2.setPreferredSize(new Dimension(10, 16));
        jSlider2.addChangeListener(new ChangeListener() {
          public void stateChanged(ChangeEvent evt) {
            updateLowerMarker();
          }
        });

      }
    }
    return jSplitPane1;
  }

  private void updateUpperMarker() {
    int pos = (int)jSlider1.getValue();
    upperMarkerScore=lower_limit+pos*(upper_limit-lower_limit)/100.0;						
    histMarker.setEndValue(upperMarkerScore);
    if (!jSlider1.getValueIsAdjusting()) {
      double[] FPTP = rawData.getFPTP(upperMarkerScore);
      upper_fprMarker.setValue(FPTP[0]);
      upper_tprMarker.setValue(FPTP[1]);
    }
  }

  private void updateLowerMarker() {
    int pos = (int)jSlider2.getValue();
    lowerMarkerScore=lower_limit+pos*(upper_limit-lower_limit)/100.0;
    histMarker.setStartValue(lowerMarkerScore);
    if (!jSlider2.getValueIsAdjusting()) {
      double[] FPTP = rawData.getFPTP(lowerMarkerScore);
      lower_fprMarker.setValue(FPTP[0]);
      lower_tprMarker.setValue(FPTP[1]);
    }
  }

  /**
   * @param listener
   * @see org.jfree.chart.plot.Marker#addChangeListener(org.jfree.chart.event.MarkerChangeListener)
   */
  public void addChangeListener(MarkerChangeListener listener) {
    histMarker.addChangeListener(listener);
  }


  private void updateHistogramDatasets() {

    if(histogramDataset.getSeriesCount()>0) {
      histogramDataset.removeAllSeries();
      fluctDataset.removeAllSeries();
      weightDataset.removeAllSeries();
      potentialDataset.removeAllSeries();
    }

    XYIntervalSeries posSeries = new XYIntervalSeries("positive");
    XYIntervalSeries negSeries = new XYIntervalSeries("negative");

    double[] posHist = rawData.computeHistogram(1, noOfBins);
    double[] negHist = rawData.computeHistogram(-1,noOfBins);

    double min=rawData.getMin(iter);
    double max=rawData.getMax(iter);

    double x=min;
    double step=(max-min)/noOfBins;
    double height=1.0;
    for(int i=0; i<noOfBins; i++){
      posSeries.add(x, x, x+(step/2), posHist[i], 0, posHist[i]);
      negSeries.add(x+(step/2),x+(step/2),x+step, negHist[i], 0, negHist[i]);
      x=x+step;
      if (posHist[i] > height) height = posHist[i];
      if (negHist[i] > height) height = negHist[i];
    }

    histogramDataset.addSeries(posSeries);
    histogramDataset.addSeries(negSeries);
    fluctDataset.addSeries(rawData.getFluctBins());
    fluctDataset.addSeries(rawData.getFluctRanges());

    if (isRobustBoost) {
      double t = averageTime[iter];
      rho = RobustBoostHelper.calculateRho(confRated, sigma_f, epsilon, theta);
      
      if (showWeight) {
        weightDataset.addSeries(RobustBoostHelper.getPosWeightPlot(confRated, sigma_f, epsilon, theta, rho, t, 
            height, min, max, step/2));
        weightDataset.addSeries(RobustBoostHelper.getNegWeightPlot(confRated, sigma_f, epsilon, theta, rho, t, 
            height, min, max, step/2));
      }

      if (showPotential) {
        potentialDataset.addSeries(RobustBoostHelper.getPosPotentialPlot(confRated, sigma_f, epsilon, theta, rho, t, 
            height, min, max, step/2));
        potentialDataset.addSeries(RobustBoostHelper.getNegPotentialPlot(confRated, sigma_f, epsilon, theta, rho, t, 
            height, min, max, step/2));
      }
    }
  }

  private JFreeChart createHistogramChart() {

    XYBarRenderer renderer1 = new XYBarRenderer();
    renderer1.setSeriesPaint(0,Color.cyan);
    renderer1.setSeriesPaint(1,Color.pink);

    XYPlot histPlot = new XYPlot(histogramDataset,
        null,
        new NumberAxis("count"),
        renderer1);

    XYBarRenderer renderer2 = new XYBarRenderer();
    renderer2.setSeriesPaint(0,Color.green);
    renderer2.setSeriesPaint(1, Color.orange);
    renderer2.setUseYInterval(true);

    if (isRobustBoost) {
      StandardXYItemRenderer renderer3 = new StandardXYItemRenderer();
      renderer3.setSeriesPaint(0, Color.blue);
      renderer3.setSeriesPaint(1, Color.red);
      renderer3.setBaseStroke(new BasicStroke(2));

      StandardXYItemRenderer renderer4 = new StandardXYItemRenderer();
      renderer4.setSeriesPaint(0, Color.blue);
      renderer4.setSeriesPaint(1, Color.red);
      renderer4.setBaseStroke(new BasicStroke(2,BasicStroke.CAP_BUTT,
          BasicStroke.JOIN_MITER,2,new float[] {2}, 0));

      histPlot.setDataset(1, weightDataset);
      histPlot.setRenderer(1, renderer3);
      
      histPlot.setDataset(2, potentialDataset);
      histPlot.setRenderer(2, renderer4);

      histPlot.setDatasetRenderingOrder(DatasetRenderingOrder.FORWARD);
    }
    
    XYPlot fluctPlot = new XYPlot(fluctDataset,
        null,
        new NumberAxis("bin"),
        renderer2);

    double initialLocation = (upper_limit+lower_limit)/2.0;
    histMarker = new IntervalMarker(initialLocation,initialLocation);
    histPlot.addDomainMarker(histMarker, Layer.BACKGROUND);
    fluctPlot.addDomainMarker(histMarker, Layer.BACKGROUND);


    //plot.setBackgroundPaint(Color.lightGray);
    //plot.setDomainGridlinePaint(Color.white);
    //plot.setRangeGridlinePaint(Color.white);

    CombinedDomainXYPlot combinedPlot = new CombinedDomainXYPlot(new NumberAxis("score"));
    combinedPlot.setGap(10.0);

    // add the subplots...
    combinedPlot.add(histPlot, 3);
    combinedPlot.add(fluctPlot, 1);
    combinedPlot.setOrientation(PlotOrientation.VERTICAL);

    JFreeChart chart = new JFreeChart(
        "Histogram",
        JFreeChart.DEFAULT_TITLE_FONT,
        combinedPlot,
        false  // legend
    );

    return chart;
  }


  private JFreeChart createRocChart(XYDataset dataset) {
    JFreeChart chart = ChartFactory.createXYLineChart(
        "ROC",      // chart title
        "False positive rate",                      // x axis label
        "True positive rate",                      // y axis label
        dataset,                  // data
        PlotOrientation.VERTICAL,
        false,                     // include legend
        true,                     // tooltips
        false                     // urls
    );

    XYPlot plot = (XYPlot) chart.getPlot();
    plot.setBackgroundPaint(Color.lightGray);
    plot.setDomainGridlinePaint(Color.white);
    plot.setRangeGridlinePaint(Color.white);

    lower_tprMarker = new ValueMarker(0.5);
    lower_tprMarker.setPaint(Color.blue);
    lower_fprMarker = new ValueMarker(0.5);
    lower_fprMarker.setPaint(Color.blue);
    plot.addRangeMarker(lower_tprMarker);
    plot.addDomainMarker(lower_fprMarker);

    upper_tprMarker = new ValueMarker(0.5);
    upper_tprMarker.setPaint(Color.red);
    upper_fprMarker = new ValueMarker(0.5);
    upper_fprMarker.setPaint(Color.red);
    plot.addRangeMarker(upper_tprMarker);
    plot.addDomainMarker(upper_fprMarker);

    return chart;

  }

  private JPanel getJPanel3() {
    if(jPanel3 == null) {
      jPanel3 = new JPanel();
      BoxLayout jPanel3Layout = new BoxLayout(jPanel3, BoxLayout.Y_AXIS);
      jPanel3.setLayout(jPanel3Layout);
      {
        jPanel3.add(getJComboBox1());
        jPanel3.add(getJScrollPane1());
        jPanel3.setPreferredSize(new java.awt.Dimension(80, 400));
      }
    }
    return jPanel3;
  }

  private JComboBox getJComboBox1() {
    if(jComboBox1 == null) {
      jComboBox1 = new JComboBox();
      jComboBox1.setMaximumSize(new Dimension(200,20));
      for (int i=0;i<allData.length;i++) {
        jComboBox1.addItem("Class " + (i+label_offset) + " vs Rest");
      }
      jComboBox1.addItemListener(new ItemListener() {
        public void itemStateChanged(ItemEvent evt) {
          if (evt.getStateChange() == ItemEvent.SELECTED) {
            //System.out.println("jComboBox1.actionPerformed, event="+evt);
            currentDataSet = jComboBox1.getSelectedIndex();
            loadDataset(currentDataSet);
          }
        }
      });
    }
    return jComboBox1;
  }


  private JScrollPane getJScrollPane1() {
    if (jScrollPane1 == null) {
      jScrollPane1 = new JScrollPane();
      jList1 = new JList(iterNoList);
      jList1.setLayout(new FlowLayout());
      jList1.setFocusable(false);
      jList1.setIgnoreRepaint(false);
      jList1.addListSelectionListener(new ListSelectionListener() {
        public void valueChanged(ListSelectionEvent evt) {
          if(!evt.getValueIsAdjusting()) {
            JList list = (JList) evt.getSource();
            iter = list.getSelectedIndex();
            loadIteration(iter);
          }
        }
      });
      jScrollPane1.getViewport().add(jList1);
    }
    return jScrollPane1;
  }

  private JMenu getJMenu1() {
    if(jMenu1 == null) {
      jMenu1 = new JMenu();
      jMenu1.setText("Tools");
      jMenu1.add(getJMenuItem1());
      jMenu1.add(getJMenuItem2());
      jMenu1.add(getJMenuItem4());
    }
    return jMenu1;
  }

  private JMenu getJMenu2() {
    if(jMenu2 == null) {
      jMenu2 = new JMenu();
      jMenu2.setText("View");
      jMenu2.add(getJMenuItem3());
      jMenu2.add(getJMenuItem5());
      jMenu2.add(getJMenuItem6());
    }
    return jMenu2;
  }

  private JMenuItem getJMenuItem1() {
    if(jMenuItem1 == null) {
      jMenuItem1 = new JMenuItem();
      jMenuItem1.setText("Print Indices");
      if (useCV && !hasIndex) jMenuItem1.setEnabled(false);
      jMenuItem1.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent evt) {
          //System.out.println("jMenuItem1.actionPerformed, event="+evt);
          dumpExamples();

        }
      });
    }
    return jMenuItem1;
  }

  private JMenuItem getJMenuItem2() {
    if(jMenuItem2 == null) {
      jMenuItem2 = new JMenuItem();
      jMenuItem2.setText("Print PDF");
      jMenuItem2.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent evt) {
          //System.out.println("jMenuItem2.actionPerformed, event="+evt);
          toPDF();
        }
      });
    }
    return jMenuItem2;
  }

  private JMenuItem getJMenuItem3() {
    if(jMenuItem3 == null) {
      jMenuItem3 = new JMenuItem();
      jMenuItem3.setText("Switch Label");
      if (numClasses != 2) jMenuItem3.setEnabled(false);
      jMenuItem3.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent evt) {
          //System.out.println("jMenuItem3.actionPerformed, event="+evt);
          switchLabel *= -1;
          try {
            allData = createDataSet();
          }
          catch (IOException e) {
            e.printStackTrace();
          }
          loadDataset(currentDataSet);
        }
      });
    }
    return jMenuItem3;
  }

  private JMenuItem getJMenuItem5() {
    if(jMenuItem5 == null) {
      jMenuItem5 = new JMenuItem();
      if (showWeight) jMenuItem5.setText("Hide Weight");
      else jMenuItem5.setText("Show Weight");
      if (!isRobustBoost) jMenuItem5.setEnabled(false);
      jMenuItem5.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent evt) {
          
          showWeight = !showWeight;
          
          if (showWeight) jMenuItem5.setText("Hide Weight");
          else jMenuItem5.setText("Show Weight");
          
          loadIteration(iter);
        }
      });
    }
    return jMenuItem5;
  }

  private JMenuItem getJMenuItem6() {
    if(jMenuItem6 == null) {
      jMenuItem6 = new JMenuItem();
      if (showPotential) jMenuItem6.setText("Hide Potential");
      else jMenuItem6.setText("Show Potential");
      if (!isRobustBoost) jMenuItem6.setEnabled(false);
      jMenuItem6.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent evt) {
        
          showPotential = !showPotential;
      
          if (showPotential) jMenuItem6.setText("Hide Potential");
          else jMenuItem6.setText("Show Potential");
          
          loadIteration(iter);
        }
      });
    }
    return jMenuItem6;
  }

  private JMenuItem getJMenuItem4() {
    if(jMenuItem4 == null) {
      jMenuItem4 = new JMenuItem();
      jMenuItem4.setText("Analyze Multi-class");
      jMenuItem4.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent evt) {
          //System.out.println("jMenuItem4.actionPerformed, event="+evt);
          try {
            analyzeMultiClass();
          } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
          }
        }
      });
    }
    return jMenuItem4;
  }


  //--------------- Info Files Parser ---------------//

  private void getHasIndexAndNumClasses() throws IOException {

    BufferedReader br;
    String aline;

    if (testFiles.length > 1) useCV = true;
    else useCV = false;

    post("Cross validation = " + useCV);

    // find out the number of classes
    br = new BufferedReader(new FileReader(testFiles[0]));
    aline = br.readLine();
    while (aline != null) {
      String[] tokens = aline.split(":");
      String firstToken = tokens[0];
      if (!firstToken.startsWith("iter")) {

        if (tokens.length < 6) hasIndex = false;
        else hasIndex = true;

        String secondLastToken = tokens[tokens.length-2].trim();
        String[] labels = secondLastToken.split(",");
        if (labels.length < 2) numClasses = 2;
        else numClasses = labels.length;
        break;
      }
      aline = br.readLine();
    }
    br.close();

    post("Indexed Info = " + hasIndex);
    post("Number of classes = " + numClasses);
  }

  private void getMaxNumIter() throws IOException {

    BufferedReader br;
    String aline;

    // find out the maximum iteration
    ArrayList<String> maxIterList = null;
    for (int i=0;i<infoFiles.length;i++) {
      ArrayList<String> currentIterList = new ArrayList<String>();
      br = new BufferedReader(new FileReader(infoFiles[i]));
      aline = br.readLine();
      while (aline != null) {
        if (aline.endsWith("#")) {
          String[] tokens = aline.split("\t");
          String firstToken = tokens[0];
          // parse iteration number
          int iterNo = Integer.parseInt(firstToken);
          currentIterList.add("Iteration " + iterNo);
        }
        aline = br.readLine();
      }
      br.close();
      if (maxIterList == null) {
        maxIterList = currentIterList;
      }
      else {
        // carry over
        if (carryOver) {
          if (currentIterList.size() > maxIterList.size()) {
            maxIterList = currentIterList;
          }
        }
        else {
          if (currentIterList.size() < maxIterList.size()) {
            maxIterList = currentIterList;
          }
        }
      }
    }
    maxNumIter = maxIterList.size();
    iterNoList = maxIterList.toArray(new String[maxNumIter]);

    if (maxNumIter == 0) {
      post("Error: number of iterations = 0");
      post("Please change logging option (-a) of JBoost.");
      throw new RuntimeException();
    }        

    post("Maximum number of iterations = " + maxNumIter);
  }

  private void getMaxNumIndices() throws IOException {

    BufferedReader br;
    String aline;

    // find out the maximum index
    maxNumIndices = -1;
    for (int i=0;i<testFiles.length;i++) {
      br = new BufferedReader(new FileReader(testFiles[i]));
      aline = br.readLine();
      while (aline != null) {
        String[] tokens = aline.split(":");
        String firstToken = tokens[0];
        if (!firstToken.startsWith("iter")) {
          String secondToken = tokens[1].trim();
          int index;
          if (hasIndex) index = Integer.parseInt(secondToken);
          else index = Integer.parseInt(firstToken.trim());
          if (index > maxNumIndices) maxNumIndices = index;
        }
        aline = br.readLine();
      }
      br.close();
    }
    maxNumIndices++;
    post("Maximum number of indices = " + maxNumIndices);
  }

  private void getRobustBoostInfo() throws IOException {

    BufferedReader br;
    String aline;

    // get epsilon, theta, sigma_f, average t and its standard deviation

    isRobustBoost = false;
    confRated = true;
    theta = 0;
    sigma_f = 0.1;
    epsilon = 0.1;

    if (infoFiles != null && infoFiles.length > 0) {

      br = new BufferedReader(new FileReader(infoFiles[0]));
      aline = br.readLine();

      while (aline != null) {

        if (aline.startsWith("booster_type")) {
          String[] tokens = aline.split(" = ");
          if (tokens.length > 1) {
            String booster = tokens[1];
            if (booster.endsWith("RobustBoost")) {
              isRobustBoost = true;
            }
          }
        }
        else if (aline.startsWith("rb_theta")) {
          String[] tokens = aline.split(" = ");
          if (tokens.length > 1) {
            String str = tokens[1];
            theta = Double.parseDouble(str); 
          }
        }
        else if (aline.startsWith("rb_sigma_f")) {
          String[] tokens = aline.split(" = ");
          if (tokens.length > 1) {
            String str = tokens[1];
            sigma_f = Double.parseDouble(str);
          }
        }
        else if (aline.startsWith("rb_epsilon")) {
          String[] tokens = aline.split(" = ");
          if (tokens.length > 1) {
            String str = tokens[1];
            epsilon = Double.parseDouble(str);
          }
        }
        else if (aline.startsWith("rb_conf_rated")) {
          String[] tokens = aline.split(" = ");
          if (tokens.length > 1) {
            if (tokens[1].compareTo("false") == 0) {
              confRated = false;
            }
          }
        }
        aline = br.readLine();
      }

      br.close();
    }

    if (isRobustBoost) {

      post("RobustBoost detected");
      post("theta = " + theta);
      post("eps = " + epsilon);
      post("sigma_f = " + sigma_f);
      post("conf_rated = " + confRated);
      
      double[][] time = new double[maxNumIter][infoFiles.length];
      for (int i=0;i<infoFiles.length;i++) {
        post(">Procesing " + infoFiles[i]);
        br = new BufferedReader(new FileReader(infoFiles[i]));
        int iterIdx = 0;
        aline = br.readLine();
        while (aline != null) {
          if (aline.endsWith("#")) {
            String[] tokens = aline.split("\t");
            String t = tokens[4];
            time[iterIdx++][i] = Double.parseDouble(t);
            if (iterIdx == maxNumIter) break;
          }
          aline = br.readLine();
        }
        br.close();
        
        // carry over
        while (iterIdx > 0 && iterIdx < maxNumIter) {
          time[iterIdx][i] = time[iterIdx-1][i];
          iterIdx++;
        }
        
      }

      
      averageTime = new double[maxNumIter];
      stdTime = new double[maxNumIter];

      NumberFormat f = new DecimalFormat("0.000");
      for (int i=0;i<maxNumIter;i++) {
        averageTime[i] = HistogramFrame.getMean(time[i]);
        stdTime[i] = HistogramFrame.getStd(time[i],averageTime[i]);
        //post("time("+i+")=" + averageTime[i] + "+/-" + stdTime[i]);

        // update iterNoList
        iterNoList[i] = iterNoList[i] +
        " [T=" + f.format(averageTime[i]) + "+/-" + f.format(stdTime[i]) + "]";
      }

    }



  }


  /**
   * Create a vector of DataSet from StringBuffer.
   * @return a vector of DataSet
   * @throws IOException
   */
  private DataSet[] createDataSet() throws IOException {

    DataSet[] dataset;
    ExampleData[] exData;
    ArrayList<IterationData> iterationData = new ArrayList<IterationData>();
    
    if (numClasses == 2) dataset = new DataSet[1];
    else dataset = new DataSet[numClasses];

    exData = new ExampleData[dataset.length];

    for (int c=0;c < dataset.length;c++) {
      dataset[c] = new DataSet(iterNoList);
      exData[c] = new ExampleData(maxNumIndices, maxNumIter, trainFiles.length);
    }

    int currentIter;
    String aline;
    BufferedReader br;

    // now get test scores

    post("Reading test scores ...");

    for (int i=0;i<testFiles.length;i++) {

      post(">Processing " + testFiles[i]);

      currentIter = -1;
      br = new BufferedReader(new FileReader(testFiles[i]));
      aline = br.readLine();
      while (aline != null) {
        String[] tokens = aline.split(":");
        String firstToken = tokens[0];
        if (firstToken.startsWith("iter")) {
          currentIter++;
          iterationData.clear();
          if (currentIter >= maxNumIter) break;
        }
        else {
          // binary case
          if (numClasses == 2) {
            String secondLastToken = tokens[tokens.length-2].trim();
            String thirdLastToken = tokens[tokens.length-3].trim();
            String secondToken = tokens[1].trim();

            // get rid of '+'
            if (secondLastToken.startsWith("+")) secondLastToken = secondLastToken.substring(1);

            int label = Integer.parseInt(secondLastToken) * switchLabel;
            double score = Double.parseDouble(thirdLastToken) * switchLabel;
            int index;

            if (hasIndex) index = Integer.parseInt(secondToken);
            else index = Integer.parseInt(firstToken.trim());

            DataElement e = new DataElement(score,index,label);
            dataset[0].addDataElement(e, currentIter);
            
            exData[0].addTestScore(index, currentIter, score);
            iterationData.add(new IterationData(score,index,label,0));
          }
          // multi-class case
          else {
            String secondLastToken = tokens[tokens.length-2].trim();
            String thirdLastToken = tokens[tokens.length-3].trim();
            String secondToken = tokens[1].trim();

            String[] scores = thirdLastToken.split(",");
            String[] labels = secondLastToken.split(",");

            int index;

            if (hasIndex) index = Integer.parseInt(secondToken);
            else index = Integer.parseInt(firstToken.trim());
       
            // for each class
            for (int c=0;c<numClasses;c++) {
              // get rid of '+'
              if (labels[c].startsWith("+")) labels[c] = labels[c].substring(1);

              int label = Integer.parseInt(labels[c]);
              double score = Double.parseDouble(scores[c]);

              DataElement e = new DataElement(score,index,label);
              dataset[c].addDataElement(e, currentIter);

              exData[c].addTestScore(index, currentIter, score);
              iterationData.add(new IterationData(score,index,label,c));
            }
          }
        }
        aline = br.readLine();
      }
      
      br.close();
      currentIter++;
      
      // carry over
      while (currentIter > 0 && currentIter < maxNumIter) {
        for (int j=0;j<iterationData.size();j++) {
          IterationData id = iterationData.get(j);
          double score = id.score;
          int index = id.index;
          int label = id.label;
          int c = id.c;

          DataElement e = new DataElement(score,index,label);
          dataset[c].addDataElement(e, currentIter);
          exData[c].addTestScore(index, currentIter, score);
        }
        currentIter++;
      }
    }

    post("Preprocessing test scores ...");

    for (int c=0;c<dataset.length;c++) {
      dataset[c].preProcessDataset();
    }

    if (useCV && hasIndex) {

      post("Reading train scores ...");

      for (int i=0;i<trainFiles.length;i++) {

        post(">Processing " + trainFiles[i]);

        currentIter = -1;
        br = new BufferedReader(new FileReader(trainFiles[i]));
        aline = br.readLine();
        while (aline != null) {
          String[] tokens = aline.split(":");
          String firstToken = tokens[0];
          if (firstToken.startsWith("iter")) {
            currentIter++;
            iterationData.clear();
            if (currentIter >= maxNumIter) break;
          }
          else {
            // binary case
            if (numClasses == 2) {
              String scoreToken = tokens[tokens.length-5].trim();
              String secondToken = tokens[1].trim();

              double score = Double.parseDouble(scoreToken) * switchLabel;

              int index;

              if (hasIndex) index = Integer.parseInt(secondToken);
              else index = Integer.parseInt(firstToken.trim());
       
              exData[0].addTrainScore(index, currentIter, score);
              iterationData.add(new IterationData(score,index,0,0));
            }
            // multiclass case
            else {
              String scoreToken = tokens[tokens.length-5].trim();
              String secondToken = tokens[1].trim();

              String[] scores = scoreToken.split(",");

              int index;

              if (hasIndex) index = Integer.parseInt(secondToken);
              else index = Integer.parseInt(firstToken.trim());
              
              // for each class
              for (int c=0;c<numClasses;c++) {
                double score = Double.parseDouble(scores[c]);
                exData[c].addTrainScore(index, currentIter, score);
                iterationData.add(new IterationData(score,index,0,c));
              }
            }
          }
          aline = br.readLine();
        }
        br.close();
        currentIter++;
        
        // carry over
        while (currentIter > 0 && currentIter < maxNumIter) {
          for (int j=0;j<iterationData.size();j++) {
            IterationData id = iterationData.get(j);
            double score = id.score;
            int index = id.index;
            int c = id.c;

            exData[c].addTrainScore(index, currentIter, score);
          }
          currentIter++;
        }
        
      }

      post("Calculating Fluctuation ... ");

      for (int c=0;c<dataset.length;c++) {

        post(">Processing class " + (c+label_offset));

        dataset[c].preProcessDataset();

        for (int iter=0;iter < maxNumIter;iter++) {

        	double iterMin = dataset[c].getMin(iter);
        	double iterMax = dataset[c].getMax(iter);
        	
          int fluctBins = 20;
          double percentage = 0.05;
          int barHeight = 6;
          double binWidth = (iterMax - iterMin) / fluctBins;

        	
          double y = 0;
          int testScoreCount;
          
          // for each bin
          for (int b=0;b < fluctBins;b++) {

            ArrayList<Double> trainScores = new ArrayList<Double>();

            double lower = iterMin + b * binWidth;
            double upper = iterMin + (b+1) * binWidth;
            testScoreCount = 0;
            
            // for each index
            for (int i=0;i < maxNumIndices;i++) {

              // get test score
              double score = exData[c].getTestScore(i, iter);

              // if the test score is in this bin
              if (score != Double.NaN && score >= lower && score <= upper) {
                testScoreCount++;
                // get train scores
                double[] train = exData[c].getTrainScore(i, iter);
                if (train != null) {           
                  int num_train = exData[c].getNumTrainScore(i, iter);
                  for (int j=0;j<num_train;j++) trainScores.add(new Double(train[j]));
                }
              }
            }

            double yMin = y - barHeight;
            double yMax = y;
            y = y - 1.1 * barHeight;

            if (testScoreCount > 10 && trainScores.size() > 10) {
              Collections.sort(trainScores);

              int topIndex = Math.min((int)(trainScores.size() * (1 - percentage)), trainScores.size() - 1);
              int bottomIndex = Math.max((int)(trainScores.size() * percentage), 0);

              double top = (trainScores.get(topIndex)).doubleValue();
              double bottom = (trainScores.get(bottomIndex)).doubleValue();

              dataset[c].addFluctItems(iter, lower, upper, bottom, top, yMin, yMax);
            }
          }
        }
      }
    }

    post("Cleaning up ...");
    iterationData.clear();
    iterationData = null;
    for (int c=0;c<dataset.length;c++) {
      exData[c] = null;
    }

    return dataset;

  }

  //--------------- Utilities ---------------//

  /**
   * Print stuff to stdout
   * @param s
   */
  private void post(String s) {
    System.out.println(s);
  }

  private void toPDF() {

    File pdf = selectPDFFile();

    if (pdf != null) {

      JComponent toDraw = this.jSplitPane2;

      File[] tmpFiles = new File[maxNumIter];

      for (int i=0;i<maxNumIter;i++) {

        post("Printing " + iterNoList[i] + "...");

        jList1.setSelectedIndex(i);
        jList1.scrollRectToVisible(jList1.getCellBounds(i, i));
        loadIteration(i);

        BufferedImage bimg = new BufferedImage(toDraw.getWidth(),toDraw.getHeight(),BufferedImage.TYPE_INT_RGB);
        Graphics2D g = bimg.createGraphics();
        toDraw.paint(g);
        g.dispose();

        // add leading zeros
        String file_idx = Integer.toString(i);
        while (file_idx.length() < 3) file_idx = "0" + file_idx;

        try  {
          tmpFiles[i] = new File("scorevistmp" + file_idx + ".png");
          javax.imageio.ImageIO.write(bimg, "png", tmpFiles[i]);
        }
        catch (Exception e) {
          e.printStackTrace();
        }

      }

      // restore plots
      jList1.setSelectedIndex(iter);
      loadIteration(iter);

      boolean success = true;

      // call convert to make pdf
      try {
        Process p = Runtime.getRuntime().exec("convert scorevistmp*.png " + pdf.getAbsolutePath());
        p.waitFor();
      } 
      catch (Exception e) {
        success = false;
      }

      if (!success) {
        System.out.println("'convert' is missing. You need to have ImageMagick installed.");
        System.out.println("PDF is not generated but you can find PNG files in the current directory.");
      }
      else {
        /*
        for (int i=0;i<maxNumIter-1;i++) {
          tmpFiles[i].delete();
        }
        */
      	
        if (maxNumIter > 0) {
          tmpFiles[maxNumIter-1].renameTo(new File(pdf.getAbsolutePath() + ".png"));
        }

        JOptionPane.showMessageDialog(this,
            "PDF file is generated!",
            "Done",
            JOptionPane.INFORMATION_MESSAGE);
      }
    }
  }

  private void dumpExamples() {
    File txt = selectDumpFile();
    if (txt != null) {
      rawData.setOutputFilename(txt.getAbsolutePath());
      rawData.printScores(iterNoList[iter], lowerMarkerScore, upperMarkerScore);
      JOptionPane.showMessageDialog(this,
          "Operation completed successfully!",
          "Done",
          JOptionPane.INFORMATION_MESSAGE);
    }
  }

  private File selectPDFFile() {

    File fFile = new File("default.pdf");
    JFileChooser fc = new JFileChooser ();

    // Start in current directory
    fc.setCurrentDirectory (new File ("."));

    // Set filter for Java source files.
    fc.setFileFilter (new FileFilter() {

      public boolean accept(File f) {
        String path = f.getAbsolutePath();
        if (f.isDirectory() || path.endsWith(".pdf")) return true;
        else return false;
      }

      public String getDescription() {
        return "PDF Files";
      }
    });

    // Set to a default name for save.
    fc.setSelectedFile (fFile);

    // Open chooser dialog
    int result = fc.showSaveDialog (this);

    if (result == JFileChooser.CANCEL_OPTION) {
      return null;
    } else if (result == JFileChooser.APPROVE_OPTION) {
      fFile = fc.getSelectedFile ();
      if (fFile.exists ()) {
        int response = JOptionPane.showConfirmDialog (null,
            "Overwrite existing file?","Confirm Overwrite",
            JOptionPane.OK_CANCEL_OPTION,
            JOptionPane.QUESTION_MESSAGE);
        if (response == JOptionPane.CANCEL_OPTION) return null;
      }
      return fFile;
    } else {
      return null;
    }
  }

  private File selectDumpFile() {

    File fFile = new File("ExamplesDumpFile.txt");
    JFileChooser fc = new JFileChooser ();

    // Start in current directory
    fc.setCurrentDirectory (new File ("."));

    // Set filter for Java source files.
    fc.setFileFilter (new FileFilter() {

      public boolean accept(File f) {
        String path = f.getAbsolutePath();
        if (f.isDirectory() || path.endsWith(".txt")) return true;
        else return false;
      }

      public String getDescription() {
        return "Text Files";
      }
    });

    // Set to a default name for save.
    fc.setSelectedFile (fFile);

    // Open chooser dialog
    int result = fc.showSaveDialog (this);

    if (result == JFileChooser.CANCEL_OPTION) {
      return null;
    } else if (result == JFileChooser.APPROVE_OPTION) {
      fFile = fc.getSelectedFile ();
      if (fFile.exists ()) {
        int response = JOptionPane.showConfirmDialog (null,
            "Overwrite existing file?","Confirm Overwrite",
            JOptionPane.OK_CANCEL_OPTION,
            JOptionPane.QUESTION_MESSAGE);
        if (response == JOptionPane.CANCEL_OPTION) return null;
      }
      return fFile;
    } else {
      return null;
    }
  }

  private File selectMulticlassLogFile() {

    File fFile = new File("multiclass.txt");
    JFileChooser fc = new JFileChooser ();

    // Start in current directory
    fc.setCurrentDirectory (new File ("."));

    // Set filter for Java source files.
    fc.setFileFilter (new FileFilter() {

      public boolean accept(File f) {
        String path = f.getAbsolutePath();
        if (f.isDirectory() || path.endsWith(".txt")) return true;
        else return false;
      }

      public String getDescription() {
        return "Text Files";
      }
    });

    // Set to a default name for save.
    fc.setSelectedFile (fFile);

    // Open chooser dialog
    int result = fc.showSaveDialog (this);

    if (result == JFileChooser.CANCEL_OPTION) {
      return null;
    } else if (result == JFileChooser.APPROVE_OPTION) {
      fFile = fc.getSelectedFile ();
      if (fFile.exists ()) {
        int response = JOptionPane.showConfirmDialog (null,
            "Overwrite existing file?","Confirm Overwrite",
            JOptionPane.OK_CANCEL_OPTION,
            JOptionPane.QUESTION_MESSAGE);
        if (response == JOptionPane.CANCEL_OPTION) return null;
      }
      return fFile;
    } else {
      return null;
    }
  }


  private void loadIteration(int iter) {

    rawData.setIteration(iter);
    updateHistogramDatasets();

    XYSeries rocSeries = rawData.generateRoC(negLabel,posLabel);
    rocDataset.removeSeries(0);
    rocDataset.addSeries(rocSeries);
    updateUpperMarker();
    updateLowerMarker();
  }

  private void loadDataset(int idx) {
    rawData = allData[idx];
    lower_limit = rawData.getMin();
    upper_limit = rawData.getMax();

    rawData.setIteration(iter);
    updateHistogramDatasets();

    XYSeries rocSeries = rawData.generateRoC(negLabel,posLabel);
    rocDataset.removeSeries(0);
    rocDataset.addSeries(rocSeries);
    updateUpperMarker();
    updateLowerMarker();
  }

  @SuppressWarnings("unchecked")
  private void analyzeMultiClass() throws IOException {

//    if (numClasses <= 2) {
//      post("Only multiclass allowed");
//      return;
//    }

    String response = JOptionPane.showInputDialog(null,
        "True positive rate between 0 and 1", "True positive rate", JOptionPane.PLAIN_MESSAGE);

    double tp = -1;

    try {
      tp = Double.parseDouble(response);
    }
    catch (Exception e) {
      post("Invalid threshold");
      return;
    }

    if (tp <= 0 || tp >= 1) {
      post("Invalid threshold");
      return;
    }


    File f = selectMulticlassLogFile();

    if (f == null) return;

    BufferedWriter bw = new BufferedWriter(new FileWriter(f));

    String header = iterNoList[iter] + "\nTruePositiveRate=" + tp;  
    post(header); bw.write(header + "\n");

    double[] score_threshold = new double[allData.length];

    for (int c=0;c<numClasses;c++) {

      // find threshold for each class
      allData[c].setIteration(iter);
      score_threshold[c] = allData[c].getScoreAtTPThreshold(tp);
      String p = "Score threshold for class " + (c+label_offset) + "=" + score_threshold[c];
      post(p); bw.write(p + "\n");

    }

    // create a data structure for true label and predictions
    Object[] partitions = new Object[numClasses];
    for (int i=0;i<numClasses;i++) {
      partitions[i] = new TreeMap<PredictionSet,Integer>();
    }

    // open test files again
    int currentIter;
    BufferedReader br;
    String aline;
    boolean start;
    for (int i=0;i<testFiles.length;i++) {
      start = false;
      currentIter = -1;
      br = new BufferedReader(new FileReader(testFiles[i]));
      aline = br.readLine();
      while (aline != null) {
        String[] tokens = aline.split(":");
        String firstToken = tokens[0];

        if (start && !firstToken.startsWith("iter")) {

          boolean[] prediction_mask = new boolean[numClasses];
          int prediction_count = 0;
          int true_label = -1;

          String secondLastToken = tokens[tokens.length-2].trim();
          String thirdLastToken = tokens[tokens.length-3].trim();

          String[] scores = thirdLastToken.split(",");
          String[] labels = secondLastToken.split(",");

          // compare score of for each class to its threshold
          for (int c=0;c<numClasses;c++) {
            // get rid of '+'
            if (labels[c].startsWith("+")) labels[c] = labels[c].substring(1);

            int label = Integer.parseInt(labels[c]);
            double score = Double.parseDouble(scores[c]);

            if (score > score_threshold[c]) {
              prediction_mask[c] = true;
              prediction_count++;
            }
            else {
              prediction_mask[c] = false;
            }

            if (label == posLabel) true_label = c;
          }

          // create a vector of predictions
          int[] prediction = new int[prediction_count];
          int k=0;
          for (int c=0;c<numClasses;c++) {
            if (prediction_mask[c]) prediction[k++] = c; 
          }

          // make a prediction set
          PredictionSet ps = new PredictionSet(prediction);

          if (true_label >= 0 && true_label <partitions.length) {
            TreeMap<PredictionSet,Integer> treemap = (TreeMap)partitions[true_label];
            if (treemap.containsKey(ps)) {
              Integer count = treemap.get(ps);
              count = new Integer(count.intValue() + 1);
              treemap.put(ps, count);
            }
            else {
              treemap.put(ps, new Integer(1));
            }
          }

        } 

        if (firstToken.startsWith("iter")) {

          if (start) break;

          currentIter++;
          if (currentIter >= maxNumIter) break;

          if (currentIter == iter) {
            start = true; 
          }
          else {
            // skip lines
            String secondToken = tokens[1].trim();
            int numElements = Integer.parseInt(secondToken.substring(10));
            for (int j=0;j<numElements;j++) br.readLine();
          }
        }

        aline = br.readLine();
      }

      br.close();
    }

    for (int c=0;c<numClasses;c++) {
      double correct = 0;
      double total = 0;

      String p = "True label=" + (c+label_offset);
      post(p); bw.write(p + "\n");

      p = "Predictions=";
      post(p); bw.write(p + "\n");

      TreeMap<PredictionSet,Integer> treemap = (TreeMap)partitions[c];
      Iterator i = treemap.keySet().iterator();
      while (i.hasNext()) {
        PredictionSet ps = (PredictionSet)i.next();
        Integer count = treemap.get(ps);
        p = " " + ps + ":" + count;
        post(p); bw.write(p+"\n");          
        if (ps.contains(c)) correct += count.doubleValue();
        total += count.doubleValue();
      }

      p = "(total,correct,error)=("+total+","+correct+","+((total-correct)/total)+")";
      post(p); bw.write(p + "\n");
    }

    bw.close();

  }


  private static double getMean(double[] v) {
    double sum = 0;
    for (int i=0;i<v.length;i++) {
      sum += v[i];
    }
    return sum / v.length;
  }

  private static double getStd(double[] v, double mean) {
    double s = 0;
    for (int i=0;i<v.length;i++) {
      s += Math.pow(v[i] - mean, 2);
    }
    return Math.sqrt(s/v.length);
  }



  //--------------- Helper Classes ----------//

  private class ExampleData {

    int maxNumIter;
    int numTrainFolds;
    double[][] testScores;
    double[][][] trainScores;
    int[][] trainScoresIdx;


    public ExampleData(int maxNumIndices, int maxNumIter, int numTrainFolds) {
      this.maxNumIter = maxNumIter;
      this.numTrainFolds = numTrainFolds;
      trainScores = new double[maxNumIter][maxNumIndices][numTrainFolds];
      trainScoresIdx = new int[maxNumIter][maxNumIndices];
      testScores = new double[maxNumIter][maxNumIndices];
    }

    public void addTestScore(int index, int iter, double testScore) {
      testScores[iter][index] = testScore;
    }

    public double getTestScore(int index, int iter) {
      return testScores[iter][index];
    }

    public void addTrainScore(int index, int iter, double trainScore) {
      trainScores[iter][index][trainScoresIdx[iter][index]] = trainScore;
      trainScoresIdx[iter][index]++;
    }

    public int getNumTrainScore(int index, int iter) {
      return trainScoresIdx[iter][index];
    }

    public double[] getTrainScore(int index, int iter) {
      return trainScores[iter][index];
    }
    
  }

  
  private class IterationData {
    public double score;
    public int index, label, c;
    
    public IterationData(double s, int i, int l, int cc) {
      score = s;
      index = i;
      label = l;
      c = cc;
    }
    
  }
  
  private class PredictionSet implements Comparable {

    public int[] prediction;

    public PredictionSet(int[] prediction) {
      this.prediction = prediction;
      Arrays.sort(this.prediction);
    }

    public int size() {
      return prediction.length;
    }

    public int compareTo(Object o) {
      PredictionSet other = (PredictionSet)o;
      if (this.size() < other.size()) return -1;
      else if (this.size() > other.size()) return 1;
      else {
        for (int i=0;i<this.size();i++) {
          if (this.prediction[i] < other.prediction[i]) return -1;
          else if (this.prediction[i] > other.prediction[i]) return 1;
        }
      }
      return 0;
    }

    public String toString() {
      if (prediction.length == 0) return "[]";
      else {
        String ret = "[";
        for (int i=0;i<prediction.length-1;i++) {
          ret = ret + (prediction[i]+label_offset) + ",";
        }
        ret = ret + (prediction[prediction.length-1]+label_offset) + "]";
        return ret;
      }
    }

    public boolean contains(int k) {
      for (int i=0;i<prediction.length;i++) {
        if (prediction[i] == k) return true;
      }
      return false;
    }
  }




}
