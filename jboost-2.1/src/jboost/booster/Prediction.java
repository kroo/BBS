package jboost.booster;

import java.io.Serializable;

import jboost.examples.Label;

/**
 * This is the abstract definition of a prediction. A prediction is an abstract
 * object representing the output of base classifier. Predictions can be added
 * or multiplied by scalars. They also can be converted to an interpretable form
 * (index of the best class or a real-valued score for each class)
 */
public abstract class Prediction implements Serializable {

  /*
   * Creates a clone of this.
   */
  public abstract Object clone();

  /**
   * Adds another prediction object to this one. (changes object)
   */
  public abstract Prediction add(Prediction p);

  /**
   * Multiplies this by a scalar and returns it. (changes object)
   */
  public abstract Prediction scale(double w);

  /**
   * Adds a given scalar times a given prediction object to this one. (changes
   * object)
   */
  public abstract Prediction add(double w, Prediction p);

  /**
   * Converts this to a vector of "scores" for each class (where higher is
   * better).
   */
  public abstract double[] getClassScores();

  /**
   * Computes the "margins" for this prediction relative to a given "correct"
   * label. The margin need not be normalized to lie in [-1,+1]. Note that
   * several margin values may be returned for each example.
   * 
   * @param label
   *            the "correct" label
   * @return the computed margin
   */
  public abstract double[] getMargins(Label label);

  /** generate a short textual representation (shorter than "toString") */
  public abstract String shortText();

  /**
   * Check to see if two Predictions are equivalent
   * 
   * @param other
   * @return true if this Prediction is the same as the other
   */
  public abstract boolean equals(Prediction other);

  /**
   * Returns the class with the highest score. In case of ties, a label with
   * multiple values is returned.
   */
  public Label getBestClass() {
    double[] scores = getClassScores();
    double max_score = scores[0];
    int j;
    for (j = 1; j < scores.length; j++)
      if (scores[j] > max_score) max_score = scores[j];
    boolean v[] = new boolean[scores.length];
    for (j = 0; j < scores.length; j++)
      v[j] = (scores[j] == max_score);
    return new Label(v);
  }

  /**
   * Returns a preamble that would go at the beginning of C code generated by a
   * ComplexLearner. The following must be defined in the preamble: typedef
   * Prediction_t - the type of a prediction structure in the C code #define
   * reset_pred() - resets (zeros out) prediction p #define
   * add_pred(b1,b2,...,br) - adds a prediction represented by b1,...,br to p,
   * where b1,...,br would be returned by toCodeArray #define finalize_pred() -
   * converts prediction p to class scores, to be stored in the double array r
   * (unless r is NULL). Returns r[0] (or, if r is NULL, the value that would
   * have been computed for r[0] if r were not NULL).
   */
  public abstract String cPreamble();

  /**
   * Returns code that would go inside Java code generated by a ComplexLearner.
   * The following must be defined in this code: p - a static private prediction
   * object static private void reset_pred() - resets (zeros out) prediction p
   * static private void add_pred(b1,b2,...,br) - adds a prediction represented
   * by b1,...,br to p, where b1,...,br would be returned by toCodeArray static
   * private double[] finalize_pred() - converts prediction p to class scores,
   * to be stored in the returned double array.
   */
  public abstract String javaPreamble();

  /**
   * Converts to an array of doubles to be used by add_pred macro defined in
   * cPreamble.
   */
  public abstract double[] toCodeArray();

}
